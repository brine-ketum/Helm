# Default values for my-app-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Global settings
global:
  # Image pull secrets for private registries
  imagePullSecrets: []
  # - name: regcred
  
# Namespace configuration
namespace:
  create: true
  name: my-app
  labels: {}
  annotations: {}

# Basic application settings
replicaCount: 3

image:
  repository: nginx
  pullPolicy: IfNotPresent
  tag: "1.25.3-alpine"
  # For private registries
  # repository: us-west2-docker.pkg.dev/poc-project-463913/brinek-registry/my-app

# Image pull secrets (if using private registry)
imagePullSecrets: []
# - name: docker-registry-secret

nameOverride: ""
fullnameOverride: ""

# Service Account
serviceAccount:
  create: true
  annotations: {}
  name: ""
  # For workload identity
  # annotations:
  #   iam.gke.io/gcp-service-account: my-app-sa@project.iam.gserviceaccount.com

# Pod Security Context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 3000
  fsGroup: 2000
  seccompProfile:
    type: RuntimeDefault

# Container Security Context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
    - ALL
    add:
    - NET_BIND_SERVICE

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  protocol: TCP
  name: http
  annotations: {}
  # For LoadBalancer on GCP
  # type: LoadBalancer
  # annotations:
  #   cloud.google.com/load-balancer-type: "External"

# Ingress configuration
ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    # Rate limiting
    nginx.ingress.kubernetes.io/limit-rps: "10"
    nginx.ingress.kubernetes.io/limit-connections: "20"
  hosts:
    - host: my-app.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: my-app-tls
      hosts:
        - my-app.example.com

# Resource limits and requests
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

# Horizontal Pod Autoscaler
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  # Custom metrics (requires metrics server)
  metrics: []
  # - type: Pods
  #   pods:
  #     metric:
  #       name: http_requests_per_second
  #     target:
  #       type: AverageValue
  #       averageValue: 1k

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 2
  # maxUnavailable: 1

# Health checks
livenessProbe:
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  successThreshold: 1
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  successThreshold: 1
  failureThreshold: 3

# Startup probe for slow-starting containers
startupProbe:
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 3
  successThreshold: 1
  failureThreshold: 30

# Node selection
nodeSelector: {}
  # disktype: ssd
  # node-role.kubernetes.io/worker: "true"

# Tolerations for pod assignment
tolerations: []
# - key: "spot"
#   operator: "Equal"
#   value: "true"
#   effect: "NoSchedule"

# Affinity rules
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - my-app
        topologyKey: kubernetes.io/hostname

# Pod management policy
podManagementPolicy: Parallel

# Update strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0

# Environment variables
env:
  - name: APP_ENV
    value: "production"
  - name: LOG_LEVEL
    value: "info"
  - name: PORT
    value: "8080"

# Environment from ConfigMaps/Secrets
envFrom: []
# - configMapRef:
#     name: app-config
# - secretRef:
#     name: app-secrets

# ConfigMap for application configuration
configMap:
  enabled: true
  data:
    nginx.conf: |
      worker_processes auto;
      error_log /var/log/nginx/error.log warn;
      pid /tmp/nginx.pid;
      
      events {
          worker_connections 1024;
          use epoll;
          multi_accept on;
      }
      
      http {
          include /etc/nginx/mime.types;
          default_type application/octet-stream;
          
          # Security headers
          server_tokens off;
          
          # Logging
          log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                         '$status $body_bytes_sent "$http_referer" '
                         '"$http_user_agent" "$http_x_forwarded_for"';
          
          access_log /var/log/nginx/access.log main;
          
          # Performance
          sendfile on;
          tcp_nopush on;
          tcp_nodelay on;
          keepalive_timeout 65;
          types_hash_max_size 2048;
          client_max_body_size 20M;
          
          # Gzip compression
          gzip on;
          gzip_vary on;
          gzip_proxied any;
          gzip_comp_level 6;
          gzip_types text/plain text/css text/xml text/javascript 
                     application/x-javascript application/xml+rss 
                     application/javascript application/json;
          
          # Rate limiting
          limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
          
          server {
              listen 8080;
              server_name _;
              
              # Security
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;
              
              location / {
                  root /usr/share/nginx/html;
                  index index.html index.htm;
                  try_files $uri $uri/ =404;
              }
              
              location /healthz {
                  access_log off;
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }
              
              location /ready {
                  access_log off;
                  return 200 "ready\n";
                  add_header Content-Type text/plain;
              }
              
              # Prometheus metrics
              location /metrics {
                  stub_status on;
                  access_log off;
              }
          }
      }

# Secrets (use external secrets in production)
secrets:
  enabled: false
  data: {}
    # API_KEY: "base64-encoded-secret"
    # DB_PASSWORD: "base64-encoded-password"

# Volume mounts
volumeMounts:
  - name: config
    mountPath: /etc/nginx/nginx.conf
    subPath: nginx.conf
    readOnly: true
  - name: cache
    mountPath: /var/cache/nginx
  - name: tmp
    mountPath: /tmp
  - name: var-log
    mountPath: /var/log/nginx

# Volumes
volumes:
  - name: config
    configMap:
      name: "{{ include \"my-app-chart.fullname\" . }}"
  - name: cache
    emptyDir: {}
  - name: tmp
    emptyDir: {}
  - name: var-log
    emptyDir: {}

# Persistent Volume Claims
persistence:
  enabled: false
  # storageClass: "standard-rwo"
  # accessMode: ReadWriteOnce
  # size: 10Gi
  # annotations: {}

# Network Policies
networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: ingress-nginx
      - namespaceSelector:
          matchLabels:
            name: monitoring
      ports:
      - protocol: TCP
        port: 8080
  egress:
    - to:
      - namespaceSelector: {}
      ports:
      - protocol: TCP
        port: 53
      - protocol: UDP
        port: 53
    - to:
      - namespaceSelector:
          matchLabels:
            name: kube-system
      ports:
      - protocol: TCP
        port: 53
      - protocol: UDP
        port: 53

# ServiceMonitor for Prometheus
serviceMonitor:
  enabled: true
  interval: 30s
  scrapeTimeout: 10s
  labels:
    release: prometheus
  relabelings: []
  metricRelabelings: []

# Pod lifecycle hooks
lifecycle: {}
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "sleep 15"]
  # postStart:
  #   exec:
  #     command: ["/bin/sh", "-c", "echo 'Container started'"]

# Init containers
initContainers: []
# - name: init-myservice
#   image: busybox:1.35
#   command: ['sh', '-c', "until nslookup myservice.namespace.svc.cluster.local; do echo waiting for myservice; sleep 2; done"]

# Sidecar containers
sidecarContainers: []
# - name: log-collector
#   image: fluentbit/fluent-bit:2.0
#   volumeMounts:
#   - name: var-log
#     mountPath: /var/log/nginx

# Pod labels
podLabels:
  app.kubernetes.io/component: web
  app.kubernetes.io/part-of: my-app-suite
  version: "1.0.0"

# Pod annotations
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/metrics"

# Priority Class
priorityClassName: ""
# priorityClassName: "high-priority"

# DNS Policy and Config
dnsPolicy: ClusterFirst
dnsConfig: {}
  # options:
  # - name: ndots
  #   value: "2"

# Host aliases
hostAliases: []
# - ip: "127.0.0.1"
#   hostnames:
#   - "foo.local"

# Termination Grace Period
terminationGracePeriodSeconds: 30

# RBAC
rbac:
  create: true
  rules: []
  # - apiGroups: [""]
  #   resources: ["configmaps", "secrets"]
  #   verbs: ["get", "list", "watch"]

# Extra manifests to deploy
extraManifests: []
# - apiVersion: v1
#   kind: ConfigMap
#   metadata:
#     name: extra-cm
#   data:
#     key: value